{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>ArduinoOcpp is an OCPP client which runs on microcontrollers and enables EVSEs to participate in OCPP charging networks. As a software library, it can be added to the firmware of the EVSE and will become a new part of it. If the EVSE has already an internet controller, then most likely, no extra hardware is required.</p> <p>Technical introduction</p> <p>Development tools and basic prerequisites</p> <p>Documentation WIP. See the GitHub Readme or the API description as reference.</p>"},{"location":"intro-tech/","title":"Technical introduction","text":"<p>This chapter covers the technical concepts of ArduinoOcpp.</p>"},{"location":"intro-tech/#scope-of-arduinoocpp","title":"Scope of ArduinoOcpp","text":"<p>The OCPP specification defines a charger data model, operations on the data model and the resulting physical behavior on the charger side. ArduinoOcpp implements the full scope of OCPP, i.e. a minimalistic data store for the data model, the OCPP operations and an interface to the surrounding firmware.</p> <p>Another part of OCPP is its messaging mechanism, the so-called Remote Procedure Calls (RPC) framework. ArduinoOcpp also implements the specified RPC framework with the required guarantees of message delivery or the corresponding error handling.</p> <p>At the lowest layer, OCPP relies on standard WebSockets. ArduinoOcpp works with any WebSocket library and has a lean interface to integrate them.</p> <p>The high-level API in <code>ArduinoOcpp.h</code> bundles all touch points of the EVSE firmware with the OCPP library.</p> <p> Overview of the architecture </p>"},{"location":"intro-tech/#high-level-ocpp-support","title":"High-level OCPP support","text":"<p>Being a full implementation of OCPP, ArduinoOcpp handles the OCPP communication, i.e. it sends OCPP requests and processes incoming OCPP requests autonomously. The messages are triggered by the internal data model and by input from the high-level API. Incoming OCPP requests are used to update the internal data model and if an action on the charger is required, the library signals that to the main firmware through the high-level API.</p> <p>In consequence, the high-level API decouples the main firmware from the OCPP communication and hides the operations. This has the following good reasons:</p> <ul> <li>The high-level API guarantees correctnes of the OCPP integration. As soon as the charger adopts it properly, it is fully OCPP-compliant</li> <li>The hardware-near design decreases the integration effort into the firmware hugely</li> <li>The API won't change substantially for the OCPP 2.0.1 upgrade. The EVSE will get OCPP 2.0.1 support on the fly by a later firmware update</li> </ul>"},{"location":"intro-tech/#customizability","title":"Customizability","text":"<p>One core principle of the architecture of ArduinoOcpp is the customizability and the selective usage of its components.</p> <p>Selective usage of components means that the EVSE firmware can use parts of ArduinoOcpp and work with its own implementation for the rest. In that case only the selected parts of ArduinoOcpp will be compiled into the firmware. For example, the main firmware can use the RPC framework and build a custom implementation of the OCPP logic on top of it. This could be necessary if the OCPP behavior should be tightly coupled to other modules of the firmware. In a different scenario, the EVSE firmware could already contain an extensive RPC framework and the OCPP client should reuse it. Then, only the business logic and high-level API are of interest.</p> <p> Selective usage of ArduinoOcpp </p> <p>Customizations of the library allow to integrate use cases for which the high-level API is too restrictive. The high-level API is designed to provide a facade for the expected usage of the library, but since the charging sector is driven by innovation, new use cases for OCPP emerge every day. If a custom use case cannot be integrated on the API level, the main firmware can access the internal data structures of ArduinoOcpp and complement the required functionality or replace parts of the internal behavior with custom implementations which fits the concrete scenarios better.</p>"},{"location":"intro-tech/#main-loop-paradigm","title":"Main-loop paradigm","text":"<p>ArduinoOcpp works with the common main-loop execution model of microcontrollers. After initialization, the EVSE firmware most likely enters a main-loop and repeats it infinitely. To run ArduinoOcpp, a call to its loop function must be placed into the main loop of the firmware. Then at each main-loop iteration, ArduinoOcpp executes its internal routines, i.e. it processes input data, updates its data model, executes operations and creates new output data. The ArduinoOcpp loop function does not block the main loop but executes immediately. This library does not contain any delay functions. Some activities of the library spread over many loop iterations like the start of a charging session which needs to await the approval of an NFC card and a hardware diagnosis of the high power electronics for example. All activities in ArduinoOcpp support the distribution over many loop calls, leading to a pseudo-parallel execution behavior.</p> <p>No separate RTOS task is needed and ArduinoOcpp does not have an internal mechanism for multi-task synchronization. However, it is of course possible to create a dedicated OCPP task, as long as extra care is taken of the synchronization.</p>"},{"location":"intro-tech/#how-the-api-works","title":"How the API works","text":"<p>The high-level API consists of four parts:</p> <ul> <li>Library lifecycle: The library has initialize functions with a few initialization options. Dynamic system components like the WebSocket adapter need to be set at initialization time. The deinitialize function reverts the library into an unitialized state. That's useful for memory inspection tools like valgrind or to disable the OCPP communication. The loop function also counts as part of the lifecycle management.</li> <li>Sensor Inputs: EVSEs are mechanical systems with a variety of sensor information. OCPP is used to send parts of the sensor readings to the server. The other part of the sensor data flows into the local charger model of ArduinoOcpp where it is further processed. To update ArduinoOcpp with the input data from the sensors, the firmware needs to bind the sensors to the library. An Input-binding, or in short Input, is a function which transfers the current sensor value to ArduinoOcpp. Inputs are callback functions which read a specific sensor value and pass the value in the return statement. The firmware defines those callback functions for each sensor and adds them to ArduinoOcpp during initialization. After initialization, ArduinoOcpp uses the callbacks and executes them to fetch the most recent sensor values.  This concept is reused for the data Outputs of the library to the firmware, where the callback applies output data from ArduinoOcpp to the firmware.</li> <li>Transaction management: OCPP considers EVSEs as vending machines. To enable payment processing and the billing of the EVSE usage, all charging activity is assigned to transactions. A big portion of OCPP is about transactions, their prerequisites, runtime and their termination scenarios. The ArduinoOcpp API breaks transactions down into an initiation and termination function and gives a transparent view on the current process status, authorization result and offline behavior strategy. For non-commercial setups, the transaction mechanism is the same but has only informational purposes.</li> <li>Device management: ArduinoOcpp implements the OCPP side of the device management operations. For the actual execution, the firmware needs to provide the charger-side implementations of the operations to ArduinoOcpp by passing handler functions to the API. For example, the OCPP server can restart the charger. Upon receipt of the request, ArduinoOcpp terminates the transactions and eventually triggers the system restart using the handler function which the firmware has provided through the high-level API.</li> </ul>"},{"location":"intro-tech/#transaction-safety","title":"Transaction safety","text":"<p>Software in EVSEs needs to withstand hazardous operating conditions. EVSEs are located on the street or in garages where the WiFi or LTE signal strength is often weak, leading to long offline periods or where random power cuts can occur. In addition to that, the lack of process virtualization on microcontrollers means that a malfunction in one part of the firmware leads to the crash of all other parts.</p> <p>The transaction process of ArduinoOcpp is robust against random failures or resets. A minimal transaction log on the flash storage ensures that each operation on a transaction is fully executed. It will always result in a consistent state between the EVSE and the OCPP server, even over resets of the microcontroller. The RPC queue facilitates this by tracking the delivery status of relevant messages. If the microcontroller is reset while the delivery status of a message is unknown, ArduinoOcpp takes up the message delivery again at the next start up and completes it.</p> <p>A requirement for the transaction safety feature is the availability of a journaling file system. Examples include LittleFS, SPIFFS and the POSIX file API, but some microcontroller platforms don't support this natively, so an extension would be required.</p>"},{"location":"intro-tech/#unit-testing","title":"Unit testing","text":"<p>ArduinoOcpp includes a number of unit tests based on the Catch2 framework. A GitHub Action runs the unit tests against each new commit in the ArduinoOcpp repository, which ensures that new features don't break old code.</p> <p>The scope of the unit tests is to to ensure a correct implementation of OCPP and to validate the high-level API against its definition. For that, it is not necessary to establish an actual test connection to an OCPP server. In fact, real-world communication would disturb the tests and make them undeterministic. That's why the test suite is fully based on an integrated, tiny OCPP test server which the OCPP client reaches over a loopback connection. The test suite does not access the WebSocket library. When making the unit tests of the main firmware, it is not necessary to check the full OCPP communication, but only to validate correct usage of the high-level API. An example of how the library can be initialized with a loopback connection can be found in its test suite.</p>"},{"location":"intro-tech/#microcontroller-optimization","title":"Microcontroller optimization","text":"<p>As a library for microcontrollers, the design of ArduinoOcpp considers the strict memory limits and complies with the best practices of embedded software development. Also, a few measures were taken to optimize the memory usage which include the spare inclusion of external libraries, an optimization of the internal data structures and the exclusion of C++ run-time type information (RTTI) and exceptions. Features of C++ which may have a larger footprint are carefully used such as the standard template library (STL) and lambda functions. The STL increases the robustness of the code and lambdas prove to be a powerful tool to deal with the complexity of asynchronous data processing in embedded systems. That's also why the high-level API has many functional parameters.</p> <p>Because of the high importance of C in the embedded world, ArduinoOcpp provides its high-level API in C too. It is typically simple to instruct the compiler to compile and link the C++-based library in a C-based firmware development. In case that the firmware requires custom features which are not part of the C-API, then the firmware can implement it in a new C++ source file, export the new functions to the C namespace and use it normally in the main source.</p> <p>While memory constraints are of concern, the execution time generally is not. OCPP is rather uncomplex on the algorithmic side for clients, since there is no need for elaborate planning algorithms or complex data transformations.</p> <p>Although ArduinoOcpp is optimized for the usage on microcontrollers, it is also suitable for embedded Linux systems. With more memory available, the upper limits of the internal data structures can be increased, leading to a more versatile support of charging use cases. Also, the separation of the charger firmware into multiple processes can lead to more robustness. ArduinoOcpp can be extended by an inter-process communication (IPC) interface to run in a separate process.</p>"},{"location":"modules/","title":"Internal datastructures","text":"<p>The API exposes some of the internal datastructures to the main firmware. This chapter gives an overview of their fields and shows how to use them to achieve the desired behavior.</p>"},{"location":"modules/#context-object","title":"Context object","text":"<p>The Context contains all runtime data of ArduinoOcpp. Every data object which this library creates is stored in the Context instance, except only the Configuration. So it is the basic entry point to the internals of the library. The structure of the context follows the main architecture as described in this introduction and consists of the Request queue and message deserializer for the RPC framework and the Model object for the OCPP model and behavior (see below).</p> <p>When the library is initialized, <code>getOcppContext()</code> returns the current Context object.</p>"},{"location":"modules/#model-object","title":"Model object","text":"<p>The Model represents the OCPP device model and behavior. OCPP defines a rough charger model, i.e. the hardware parts of the charger and their basic functionality in relation to the OCPP operations. Furthermore, OCPP specifies a few only software related features like the reservation of the charger. This charger model is implemented as straightforward C++ data structures and corresponding algorithms.</p> <p>The implementation of the Model is structured into a top-level Model class and the subordinate Service classes. Each Service class represents a functional block of the OCPP specification and implements the corresponding data structures and functionality. The definition of the functional blocks in ArduinoOcpp is very similar to the feature profiles in OCPP. Only the Core profile is split into multiple functional blocks to keep a smaller module scope.</p> <p>The following subsections contain a description of each functional block.</p>"},{"location":"modules/#authorization","title":"Authorization","text":"<p>The AuthorizationService manages the authorization information of user identifiers or idTags. If the local authorization features of OCPP are enabled, then this Service stores a whitelist and blacklist of idTags or maintains a cache of recently authorized identifiers. A further responsibility is to determine if the given authorization data is still valid according to the rules in the OCPP specification.</p> <p>A single idTag and its authorization information is represented by the AuthorizationData class. It has public getter functions to retreive the authorization information. The list containing those entries is implemented in the AuthorizationList class. It has a search function for the AuthorizationData by idTag.</p>"},{"location":"modules/#boot","title":"Boot","text":"<p>The BootService implements the behavior around the BootNotification message.</p> <p>Documentation WIP. See the GitHub Readme or the API description as reference.</p>"},{"location":"prerequisites/","title":"Development tools and basic prerequisites","text":"<p>This page explains how to work with this library using the appropriate development tools. Skip it if your IDE is set up and you already have an OCPP test server.</p>"},{"location":"prerequisites/#development-tools-prerequisites","title":"Development tools prerequisites","text":"<p>Throughout these document pages, it is assumed that you already have set up your development environment and that you are familiar with the corresponding building, flashing and (basic) debugging routines. ArduinoOcpp runs in many environments (from the Arduino-IDE to proprietary microcontroller IDEs like the Code Composer Studio). If you do not have any preferences yet, it is highly recommended to get started with VSCode + the PlatformIO add-on, since it is the favorite setup of the community and therefore you find the most related information in the Issues pages of the main repository.</p> <p>There are many high-quality tutorials for out there for setting up VSCode + PIO. The following site covers everything you need to know: https://randomnerdtutorials.com/vs-code-platformio-ide-esp32-esp8266-arduino/</p> <p>Once that's done, adding ArduinoOcpp is no big deal anymore. However, let's discuss another very important tool for your project first.</p>"},{"location":"prerequisites/#ocpp-server-prerequisites","title":"OCPP Server prerequisites","text":"<p>ArduinoOcpp is just a client, but all the magic of OCPP lives in the communication between a client and a server. Although it is possible to run ArduinoOcpp without a real server for testing purposes, the best approach for getting started is to get the hands on a real server. So you can always use the client in a practical setup, see immediate results and simplify development a lot.</p> <p>Perhaps you were already given access to an OCPP server for your project. Then you can use that, it should work fine. If you don't have a server already, it is highly recommended to get SteVe (https://github.com/steve-community/steve). It allows to control every detail of the OCPP operations and shows detail-rich information about the results. And again, it is the favorite test server of the community, so you will find the most related information on the Web. For the installation instructions, please refer to the SteVe docs.</p> <p>In case you can't wait to get started, you can make the first connection test with a WebSocket echo server as a fake OCPP service. ArduinoOcpp supports that: it can send all messages to an echo server which reflects all traffic. ArduinoOcpp gets back its own messages and replies to itself with mocked responses. Complicated, but it does work and the console will show a valid OCPP communication. An example echo server is given in the following section. For the further development though, you will definitely need a real OCPP server.</p>"},{"location":"prerequisites/#project-structure","title":"Project structure","text":"<p>ArduinoOcpp is a library, i.e. it is not a full firmware, but just solves one specific task in your project which is the OCPP connectivity. The project structure should reflect this: typically you download ArduinoOcpp into a libraries or dependencies subfolder, while the main part of the development takes place in a main source folder. All dependencies of ArduinoOcpp (i.e. ArduinoJson, see the dependencies sections) should be located in the same libraries or dependencies folder.</p> <p>When the include paths are correctly set up, you should be able <code>#include &lt;ArduinoOcpp.h&gt;</code> at the top of your own source files. This setup keeps the OCPP library source separate from your integration and gives the project a clear structure.</p>"},{"location":"prerequisites/#dependency-managers","title":"Dependency managers","text":"<p>Currently, the PlatformIO dependency manager is supported. In the <code>platformio.ini</code> manifest, you can add <code>matth-x/ArduinoOcpp</code> to the <code>lib_deps</code> section.</p>"}]}